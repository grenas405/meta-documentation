# LLM Collaboration: AI-Augmented Development

**Patterns for effective human-AI collaboration**

---

## Overview

This framework is designed for effective collaboration between humans and AI systems. These patterns ensure AI-generated code follows established principles and maintains framework integrity.

---

## How LLMs Should Use This Framework

### Pattern 1: Pre-Implementation Check

Before writing code:
1. Identify which framework area is affected
2. Reference relevant section of meta-documentation
3. Apply decision framework
4. Implement following patterns
5. Document any deviations

### Pattern 2: Code Review

When reviewing human or AI code:
1. Check against framework patterns
2. Verify security layers implemented
3. Ensure multi-tenant isolation
4. Validate testing coverage
5. Confirm documentation updated

### Pattern 3: Troubleshooting

When debugging issues:
1. Consult troubleshooting decision trees
2. Check for pattern violations
3. Review related ADRs
4. Verify framework integrity
5. Document root cause

---

## AI-Generated Code Standards

Every AI-generated code block should include:

```typescript
/**
 * AI-GENERATED CODE
 * Generated by: Claude/GPT-4/etc.
 * Date: 2025-01-15
 * Human reviewer: [Name]
 *
 * Pattern followed: [database-multi-tenancy]
 * Framework ref: [docs/06-database.md]
 *
 * Deviations: [None / List with rationale]
 *
 * Security review: ✅ Completed
 * Testing status: ✅ Tested
 */

export async function createBlog(
  siteKey: string,
  data: BlogData
): Promise<Blog> {
  // Implementation following established patterns
}
```

---

## Context Preservation Patterns

### 1. Structured Documentation References

```typescript
/**
 * @fileoverview Site health monitoring utility
 * @module core/utils/health
 * @requires core/config/env.ts - Environment configuration
 * @requires core/database/client.ts - Database connectivity
 * @follows Unix Philosophy: Single responsibility (health checking only)
 * @architecture Hub-and-spoke: Used by all sites via core/
 */
```

### 2. Explicit Dependencies

```typescript
// Document why this exists and how it fits
/**
 * Validates site configuration against framework requirements.
 * Part of centralized architecture - ensures all sites follow
 * consistent patterns while maintaining individual identity.
 */
export function validateSiteConfig(config: SiteConfig): boolean {
  // Implementation
}
```

### 3. Decision Documentation

```typescript
/**
 * ARCHITECTURAL DECISION RECORD (ADR)
 *
 * Decision: Use symbolic links instead of npm/git submodules
 * Rationale: Prevents version drift while maintaining flexibility
 * Trade-offs: Requires careful deployment scripting
 * Alternatives considered: Git submodules, NPM packages
 *
 * Unix Philosophy alignment:
 * - Simplicity: Single source of truth
 * - Composability: Sites can override components
 * - Transparency: Clear relationships
 */
```

---

## AI-Friendly Code Patterns

Structure code for easy understanding and modification:

```typescript
// ✅ GOOD: Clear interfaces and explicit types
interface HealthCheckResult {
  serviceName: string;
  status: 'healthy' | 'unhealthy' | 'degraded';
  responseTimeMs: number;
  lastChecked: string;
  details?: string;
}

// ✅ GOOD: Self-documenting function names
export async function checkServiceHealth(
  serviceName: string,
  endpoint: string,
  timeoutMs: number = 5000
): Promise<HealthCheckResult> {
  // Implementation is predictable and follows patterns
}

// ✅ GOOD: Consistent error handling
export class DenoGenesisError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly context?: Record<string, unknown>
  ) {
    super(message);
    this.name = 'DenoGenesisError';
  }
}
```

---

## Collaboration Workflow

### Human Developer Workflow

1. **Define Requirements**: Clear, specific requirements
2. **AI Implementation**: AI generates code following patterns
3. **Human Review**: Verify against framework standards
4. **Testing**: Validate functionality and security
5. **Integration**: Merge with confidence

### AI Assistant Workflow

1. **Read Framework Docs**: Understand patterns and principles
2. **Apply Decision Trees**: Use established decision frameworks
3. **Generate Code**: Follow patterns exactly
4. **Document Rationale**: Explain choices and deviations
5. **Suggest Tests**: Provide test cases

---

## Quality Gates for AI Code

Before accepting AI-generated code:

### Unix Philosophy Compliance
- [ ] Single responsibility per module
- [ ] Composable functions
- [ ] Text-based configuration
- [ ] Explicit dependencies
- [ ] Minimal output

### Security Implementation
- [ ] Explicit Deno permissions
- [ ] Input validation with schemas
- [ ] Parameterized SQL queries
- [ ] Multi-tenant isolation (site_key)
- [ ] Defense-in-depth layers

### Code Quality
- [ ] Follows naming conventions
- [ ] Properly documented
- [ ] Type-safe
- [ ] No code duplication
- [ ] Tests included

---

## Common AI Pitfalls to Avoid

### 1. Over-Engineering

```typescript
// ❌ AI tendency: Complex abstractions
class AbstractFactoryBuilderSingleton { }

// ✅ Prefer: Simple, direct code
export function createConnection(config: Config) { }
```

### 2. Missing Security Layers

```typescript
// ❌ AI might forget: site_key filtering
await db.query("SELECT * FROM blogs");

// ✅ Always include: Multi-tenant isolation
await db.query("SELECT * FROM blogs WHERE site_key = ?", [siteKey]);
```

### 3. Verbose Output

```typescript
// ❌ AI tendency: Noisy by default
console.log("Starting...");
console.log("Processing...");
console.log("Done!");

// ✅ Unix way: Quiet by default
if (options.verbose) console.log("Processing...");
```

---

## Effective Prompting

### Good Prompts for AI

```
"Implement a blog creation function following the multi-tenant
pattern from docs/06-database.md. Include:
- site_key parameter
- Input validation using Zod
- Parameterized SQL query
- Proper error handling
- JSDoc documentation"
```

### Poor Prompts

```
"Make a function to create blogs"
```

---

## Human Review Checklist

When reviewing AI-generated code:

1. **Pattern Compliance**: Matches established patterns?
2. **Security**: All layers implemented?
3. **Testing**: Tests included and passing?
4. **Documentation**: Clear and complete?
5. **Simplicity**: No unnecessary complexity?

---

## Summary

Effective AI collaboration requires:
- **Clear patterns**: AI follows established conventions
- **Explicit documentation**: Context is preserved
- **Human oversight**: Critical review before merge
- **Quality gates**: Standards enforced consistently

**Remember**: AI is a powerful tool when guided by human judgment and clear principles.

---

## Next Steps

- **[02-core-principles.md](./02-core-principles.md)** - Review Unix Philosophy
- **[10-decision-trees.md](./10-decision-trees.md)** - Use decision frameworks

---

**Core Insight**: AI + Human + Good Patterns = Exponential productivity
